# Генерация мультипликативных троек Бивера с использованием Paillier

Реализация протокола генерации мультипликативных троек (троек Бивера) для двух сторон без участия доверенной третьей стороны (Trusted Third Party).

## Описание задачи

Тройка Бивера (Beaver triple) — это тройка значений (a, b, c), где c = a × b (mod m), используемая в протоколах многосторонних вычислений (MPC) для эффективного умножения секретных значений.

В данной реализации две стороны генерируют разделения (shares) троек:
- Сторона 1 получает (a₁, b₁, c₁)
- Сторона 2 получает (a₂, b₂, c₂)

Таким образом, что:
```
(a₁ + a₂) × (b₁ + b₂) = c₁ + c₂ (mod MPC_MODULO)
```

## Протокол

### Используемая криптосистема
Протокол использует криптосистему Paillier, которая обладает гомоморфными свойствами:
- **Гомоморфность по сложению**: Enc(m₁) × Enc(m₂) = Enc(m₁ + m₂)
- **Скалярное умножение**: Enc(m)^k = Enc(k × m)

### Шаги протокола

1. **Инициализация (Сторона 1)**:
   - Генерирует пару ключей Paillier: (public_key, private_key)
   - Отправляет public_key стороне 2

2. **Для каждой тройки**:
   
   **Сторона 1**:
   - Выбирает случайные a₁, b₁ ∈ [0, MPC_MODULO)
   - Вычисляет Enc(a₁) и Enc(b₁)
   - Отправляет Enc(a₁), Enc(b₁) стороне 2
   
   **Сторона 2**:
   - Выбирает случайные a₂, b₂ ∈ [0, MPC_MODULO)
   - Получает Enc(a₁) и Enc(b₁)
   - Используя гомоморфные свойства, вычисляет:
     ```
     Enc(a₁×b₂ + a₂×b₁ + a₂×b₂) = Enc(a₁)^b₂ × Enc(b₁)^a₂ × Enc(a₂×b₂)
     ```
   - Отправляет результат стороне 1
   - Сохраняет c₂ = a₂ × b₂ (mod MPC_MODULO)
   
   **Сторона 1**:
   - Получает и расшифровывает: s = a₁×b₂ + a₂×b₁ + a₂×b₂
   - Вычисляет c₁ = a₁×b₁ + s (mod MPC_MODULO)

3. **Проверка корректности**:
   ```
   c₁ + c₂ = a₁×b₁ + (a₁×b₂ + a₂×b₁ + a₂×b₂) + a₂×b₂
          = a₁×b₁ + a₁×b₂ + a₂×b₁ + a₂×b₂
          = (a₁ + a₂) × (b₁ + b₂)
   ```

## Структура проекта

```
.
├── config.py              # Конфигурация (размеры ключей, модуль)
├── party1.py              # Код для стороны 1
├── party2.py              # Код для стороны 2
├── mul.py                 # Скрипт проверки корректности
├── Dockerfile             # Docker образ для контейнеров
├── docker-compose.yml     # Оркестрация контейнеров
├── requirements.txt       # Python зависимости
├── run.sh                 # Скрипт запуска (Linux/Mac)
├── run.bat                # Скрипт запуска (Windows)
└── shared/                # Директория для CSV файлов
    ├── p1.csv            # Тройки стороны 1
    └── p2.csv            # Тройки стороны 2
```

## Требования

- Docker и Docker Compose
- Python 3.9+ (для запуска mul.py вне контейнера)

## Установка и запуск

### Linux/Mac:

```bash
# Дать права на выполнение
chmod +x run.sh

# Запустить генерацию
./run.sh
```

### Windows:

```cmd
# Запустить генерацию
run.bat
```

### Ручной запуск:

```bash
# 1. Создать директорию для результатов
mkdir -p shared

# 2. Собрать Docker образы
docker-compose build

# 3. Запустить контейнеры
docker-compose up

# 4. Проверить результаты
python mul.py
```

## Результаты

После успешного выполнения будут созданы два CSV файла:

### p1.csv (тройки стороны 1)
```csv
a,b,c
1234567890,9876543210,12345678901234567890
...
```

### p2.csv (тройки стороны 2)
```csv
a,b,c
2345678901,8765432109,20515827910909
...
```

## Проверка корректности

Скрипт `mul.py` проверяет, что для каждой пары троек выполняется свойство:
```
(a₁ + a₂) × (b₁ + b₂) ≡ c₁ + c₂ (mod MPC_MODULO)
```

А также демонстрирует использование троек для MPC-умножения.

## Конфигурация

В файле `config.py` можно изменить параметры:

```python
# Размер ключа Paillier (в битах)
PAILLIER_KEY_SIZE = 2048  # Можно: 1024, 2048, 3072, 4096

# Модуль для MPC операций
MPC_MODULO = 2**32  # Можно изменить на любое число
```

**Важно**: При изменении параметров нужно пересобрать Docker образы:
```bash
docker-compose build --no-cache
```

## Коммуникация между сторонами

Для обмена данными используется `torch.distributed` с бэкендом `gloo`:
- **Транспорт**: TCP/IP
- **Режим**: Point-to-point (send/recv)
- **Формат данных**: сериализация через pickle

Контейнеры связаны через Docker сеть `mpc_network`.

## Безопасность

### Гарантии:
- Ни одна сторона не знает полные значения a, b, c
- Каждая сторона знает только свою долю
- Без закрытого ключа сторона 2 не может расшифровать Enc(a₁), Enc(b₁)

### Важные замечания:
- Это учебная реализация, не предназначенная для production
- В реальных системах нужны дополнительные меры:
  - Аутентификация сторон
  - Защита от активных атак
  - Проверка корректности вычислений (ZK-proofs)

## Использование троек для MPC-умножения

Пример в `mul.py` показывает, как использовать тройки Бивера для умножения секретных значений:

```python
# Стороны имеют секретные доли x₁, y₁ и x₂, y₂
# Цель: вычислить (x₁+x₂) × (y₁+y₂) без раскрытия долей

# 1. Используя тройку (a₁,b₁,c₁) и (a₂,b₂,c₂):
d = (x₁ - a₁) + (x₂ - a₂)  # открывается
e = (y₁ - b₁) + (y₂ - b₂)  # открывается

# 2. Каждая сторона вычисляет свою долю результата:
z₁ = c₁ + d×b₁ + e×a₁
z₂ = c₂ + d×b₂ + e×a₂ + d×e

# 3. Результат: z₁ + z₂ = (x₁+x₂) × (y₁+y₂)
```
Лицензия
Этот проект предоставляется в образовательных целях.

Автор
Dimov Roman

Примечание: Это учебная реализация. Для использования в продакшене требуется дополнительное укрепление безопасности и оптимизация производительности.
